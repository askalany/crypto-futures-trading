[
    {
        "label": "consts",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "consts",
        "description": "consts",
        "detail": "consts",
        "documentation": {}
    },
    {
        "label": "BASE_URL",
        "importPath": "consts",
        "description": "consts",
        "isExtraImport": true,
        "detail": "consts",
        "documentation": {}
    },
    {
        "label": "KEY",
        "importPath": "consts",
        "description": "consts",
        "isExtraImport": true,
        "detail": "consts",
        "documentation": {}
    },
    {
        "label": "SECRET",
        "importPath": "consts",
        "description": "consts",
        "isExtraImport": true,
        "detail": "consts",
        "documentation": {}
    },
    {
        "label": "TIF",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatchNone",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatchQueue",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "Side",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TickerSymbol",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TIF",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatch",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatchNone",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "Side",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TickerSymbol",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TIF",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "Strategy",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TickerSymbol",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TIF",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatch",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatchNone",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "Side",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TickerSymbol",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TIF",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatchQueue",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "Side",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "Strategy",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TickerSymbol",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TIF",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatch",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatchNone",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatchQueue",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "Side",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TickerSymbol",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "create_order",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_scaled_amounts",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "print_date_and_time",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "create_multiple_orders",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "create_order",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_orders_quantities_and_prices",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "concurrent.futures",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "typer",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typer",
        "description": "typer",
        "detail": "typer",
        "documentation": {}
    },
    {
        "label": "config_logging",
        "importPath": "binance.lib.utils",
        "description": "binance.lib.utils",
        "isExtraImport": true,
        "detail": "binance.lib.utils",
        "documentation": {}
    },
    {
        "label": "UMFuturesWebsocketClient",
        "importPath": "binance.websocket.um_futures.websocket_client",
        "description": "binance.websocket.um_futures.websocket_client",
        "isExtraImport": true,
        "detail": "binance.websocket.um_futures.websocket_client",
        "documentation": {}
    },
    {
        "label": "HTTPAdapter",
        "importPath": "requests.adapters",
        "description": "requests.adapters",
        "isExtraImport": true,
        "detail": "requests.adapters",
        "documentation": {}
    },
    {
        "label": "HTTPAdapter",
        "importPath": "requests.adapters",
        "description": "requests.adapters",
        "isExtraImport": true,
        "detail": "requests.adapters",
        "documentation": {}
    },
    {
        "label": "print",
        "importPath": "rich",
        "description": "rich",
        "isExtraImport": true,
        "detail": "rich",
        "documentation": {}
    },
    {
        "label": "print",
        "importPath": "rich",
        "description": "rich",
        "isExtraImport": true,
        "detail": "rich",
        "documentation": {}
    },
    {
        "label": "RichHandler",
        "importPath": "rich.logging",
        "description": "rich.logging",
        "isExtraImport": true,
        "detail": "rich.logging",
        "documentation": {}
    },
    {
        "label": "cancel_all_orders",
        "importPath": "repo",
        "description": "repo",
        "isExtraImport": true,
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "close_listen_key",
        "importPath": "repo",
        "description": "repo",
        "isExtraImport": true,
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "get_listen_key",
        "importPath": "repo",
        "description": "repo",
        "isExtraImport": true,
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "get_available_balance",
        "importPath": "repo",
        "description": "repo",
        "isExtraImport": true,
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "get_hedge_position_amount",
        "importPath": "repo",
        "description": "repo",
        "isExtraImport": true,
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "get_leverage",
        "importPath": "repo",
        "description": "repo",
        "isExtraImport": true,
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "get_mark_price",
        "importPath": "repo",
        "description": "repo",
        "isExtraImport": true,
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "new_order",
        "importPath": "repo",
        "description": "repo",
        "isExtraImport": true,
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "trade",
        "importPath": "trade",
        "description": "trade",
        "isExtraImport": true,
        "detail": "trade",
        "documentation": {}
    },
    {
        "label": "work",
        "importPath": "trade",
        "description": "trade",
        "isExtraImport": true,
        "detail": "trade",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClientError",
        "importPath": "binance.error",
        "description": "binance.error",
        "isExtraImport": true,
        "detail": "binance.error",
        "documentation": {}
    },
    {
        "label": "UMFutures",
        "importPath": "binance.um_futures",
        "description": "binance.um_futures",
        "isExtraImport": true,
        "detail": "binance.um_futures",
        "documentation": {}
    },
    {
        "label": "cancel_all_orders_request",
        "importPath": "network",
        "description": "network",
        "isExtraImport": true,
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "close_listen_key_request",
        "importPath": "network",
        "description": "network",
        "isExtraImport": true,
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_account_info_request",
        "importPath": "network",
        "description": "network",
        "isExtraImport": true,
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_leverage_request",
        "importPath": "network",
        "description": "network",
        "isExtraImport": true,
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_listen_key_request",
        "importPath": "network",
        "description": "network",
        "isExtraImport": true,
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_mark_price_request",
        "importPath": "network",
        "description": "network",
        "isExtraImport": true,
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_open_orders_request",
        "importPath": "network",
        "description": "network",
        "isExtraImport": true,
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_position_risk_request",
        "importPath": "network",
        "description": "network",
        "isExtraImport": true,
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "new_order_request",
        "importPath": "network",
        "description": "network",
        "isExtraImport": true,
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "new_price_match_order_request",
        "importPath": "network",
        "description": "network",
        "isExtraImport": true,
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "test_key",
        "kind": 2,
        "importPath": "tests.consts_test",
        "description": "tests.consts_test",
        "peekOfCode": "def test_key():\n    assert (\n        consts.KEY == \"1bd171c9e4c7831ace3c358d9c93ba3cc0304728d90a243830428a2c0dabfead\"\n    )\ndef test_secret():\n    assert (\n        consts.SECRET\n        == \"787a28958d7d9ce9e189527b2b4d8a4b608c8474d6447a23c3c88d9ff81c1269\"\n    )\ndef test_base_url():",
        "detail": "tests.consts_test",
        "documentation": {}
    },
    {
        "label": "test_secret",
        "kind": 2,
        "importPath": "tests.consts_test",
        "description": "tests.consts_test",
        "peekOfCode": "def test_secret():\n    assert (\n        consts.SECRET\n        == \"787a28958d7d9ce9e189527b2b4d8a4b608c8474d6447a23c3c88d9ff81c1269\"\n    )\ndef test_base_url():\n    assert consts.BASE_URL == \"https://testnet.binancefuture.com\"",
        "detail": "tests.consts_test",
        "documentation": {}
    },
    {
        "label": "test_base_url",
        "kind": 2,
        "importPath": "tests.consts_test",
        "description": "tests.consts_test",
        "peekOfCode": "def test_base_url():\n    assert consts.BASE_URL == \"https://testnet.binancefuture.com\"",
        "detail": "tests.consts_test",
        "documentation": {}
    },
    {
        "label": "test_asd",
        "kind": 2,
        "importPath": "tests.test_network",
        "description": "tests.test_network",
        "peekOfCode": "def test_asd():\n    assert 1 == 1",
        "detail": "tests.test_network",
        "documentation": {}
    },
    {
        "label": "order_value",
        "kind": 2,
        "importPath": "tests.test_utils",
        "description": "tests.test_utils",
        "peekOfCode": "def order_value():\n    symbol = TickerSymbol.BTCUSDT\n    side = Side.BUY\n    quantity = 1.0\n    price = 1.0\n    positionSide = PositionSide.LONG\n    type = OrderType.LIMIT\n    timeInForce = TIF.GTC\n    priceMatch = PriceMatchNone.NONE\n    return symbol, side, quantity, price, positionSide, type, timeInForce, priceMatch",
        "detail": "tests.test_utils",
        "documentation": {}
    },
    {
        "label": "test_create_order_price",
        "kind": 2,
        "importPath": "tests.test_utils",
        "description": "tests.test_utils",
        "peekOfCode": "def test_create_order_price():\n    (\n        symbol,\n        side,\n        quantity,\n        price,\n        positionSide,\n        type,\n        timeInForce,\n        priceMatch,",
        "detail": "tests.test_utils",
        "documentation": {}
    },
    {
        "label": "test_create_order_price_value",
        "kind": 2,
        "importPath": "tests.test_utils",
        "description": "tests.test_utils",
        "peekOfCode": "def test_create_order_price_value():\n    (\n        symbol,\n        side,\n        quantity,\n        price,\n        positionSide,\n        type,\n        timeInForce,\n        priceMatch,",
        "detail": "tests.test_utils",
        "documentation": {}
    },
    {
        "label": "test_create_order_price_match",
        "kind": 2,
        "importPath": "tests.test_utils",
        "description": "tests.test_utils",
        "peekOfCode": "def test_create_order_price_match():\n    (\n        symbol,\n        side,\n        quantity,\n        price,\n        positionSide,\n        type,\n        timeInForce,\n        priceMatch,",
        "detail": "tests.test_utils",
        "documentation": {}
    },
    {
        "label": "test_scaled_amounts",
        "kind": 2,
        "importPath": "tests.test_utils",
        "description": "tests.test_utils",
        "peekOfCode": "def test_scaled_amounts():\n    expected_list = [\n        5.865743125390515,\n        5.924400556644421,\n        5.9836445622108645,\n        6.043481007832973,\n        6.103915817911304,\n        6.164954976090415,\n        6.226604525851319,\n        6.2888705711098325,",
        "detail": "tests.test_utils",
        "documentation": {}
    },
    {
        "label": "test_scaled_amounts_sum",
        "kind": 2,
        "importPath": "tests.test_utils",
        "description": "tests.test_utils",
        "peekOfCode": "def test_scaled_amounts_sum():\n    expected_sum = 1000\n    result = get_scaled_amounts(total_amount=1000, volume_scale=1.01, num=100)\n    assert sum(result) == expected_sum",
        "detail": "tests.test_utils",
        "documentation": {}
    },
    {
        "label": "KEY",
        "kind": 5,
        "importPath": "consts",
        "description": "consts",
        "peekOfCode": "KEY = \"1bd171c9e4c7831ace3c358d9c93ba3cc0304728d90a243830428a2c0dabfead\"\n# The line `SECRET = \"787a28958d7d9ce9e189527b2b4d8a4b608c8474d6447a23c3c88d9ff81c1269\"` is assigning\n# a value to the variable `SECRET`. Similar to the `KEY` variable, the value assigned is a string,\n# which appears to be a secret used for authentication or authorization purposes in the code.\nSECRET = \"787a28958d7d9ce9e189527b2b4d8a4b608c8474d6447a23c3c88d9ff81c1269\"\n# The line `BASE_URL = \"https://testnet.binancefuture.com\"` is assigning a value to the variable\n# `BASE_URL`. The value assigned is a string, which represents the base URL for making API requests to\n# the Binance Futures testnet. This URL is used as the starting point for constructing the complete\n# URLs for different API endpoints.\nBASE_URL = \"https://testnet.binancefuture.com\"",
        "detail": "consts",
        "documentation": {}
    },
    {
        "label": "SECRET",
        "kind": 5,
        "importPath": "consts",
        "description": "consts",
        "peekOfCode": "SECRET = \"787a28958d7d9ce9e189527b2b4d8a4b608c8474d6447a23c3c88d9ff81c1269\"\n# The line `BASE_URL = \"https://testnet.binancefuture.com\"` is assigning a value to the variable\n# `BASE_URL`. The value assigned is a string, which represents the base URL for making API requests to\n# the Binance Futures testnet. This URL is used as the starting point for constructing the complete\n# URLs for different API endpoints.\nBASE_URL = \"https://testnet.binancefuture.com\"",
        "detail": "consts",
        "documentation": {}
    },
    {
        "label": "BASE_URL",
        "kind": 5,
        "importPath": "consts",
        "description": "consts",
        "peekOfCode": "BASE_URL = \"https://testnet.binancefuture.com\"",
        "detail": "consts",
        "documentation": {}
    },
    {
        "label": "Order",
        "kind": 6,
        "importPath": "data",
        "description": "data",
        "peekOfCode": "class Order:\n    symbol: TickerSymbol\n    side: Side\n    quantity: float\n    positionSide: PositionSide\n    price: float\n    type: OrderType = OrderType.LIMIT\n    timeInForce: TIF = TIF.GTC\n    priceMatch: PriceMatch = PriceMatchNone.NONE",
        "detail": "data",
        "documentation": {}
    },
    {
        "label": "AutoName",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class AutoName(Enum):\n    def _generate_next_value_(name, start, count, last_values):\n        return name\n# The PriceMatch class is an enumeration that represents different types of price matching options.\nclass PriceMatch(Enum):\n    def _generate_next_value_(name, start, count, last_values):\n        return name\n# The PriceMatchNone class is a subclass of PriceMatch.\nclass PriceMatchNone(PriceMatch):\n    NONE = auto()",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatch",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class PriceMatch(Enum):\n    def _generate_next_value_(name, start, count, last_values):\n        return name\n# The PriceMatchNone class is a subclass of PriceMatch.\nclass PriceMatchNone(PriceMatch):\n    NONE = auto()\n# The PriceMatchOpponent class is a subclass of PriceMatch.\nclass PriceMatchOpponent(PriceMatch):\n    OPPONENT = auto()\n    OPPONENT_5 = auto()",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatchNone",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class PriceMatchNone(PriceMatch):\n    NONE = auto()\n# The PriceMatchOpponent class is a subclass of PriceMatch.\nclass PriceMatchOpponent(PriceMatch):\n    OPPONENT = auto()\n    OPPONENT_5 = auto()\n    OPPONENT_10 = auto()\n    OPPONENT_20 = auto()\n# The PriceMatchQueue class is a subclass of PriceMatch.\nclass PriceMatchQueue(PriceMatch):",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatchOpponent",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class PriceMatchOpponent(PriceMatch):\n    OPPONENT = auto()\n    OPPONENT_5 = auto()\n    OPPONENT_10 = auto()\n    OPPONENT_20 = auto()\n# The PriceMatchQueue class is a subclass of PriceMatch.\nclass PriceMatchQueue(PriceMatch):\n    QUEUE = auto()\n    QUEUE_5 = auto()\n    QUEUE_10 = auto()",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PriceMatchQueue",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class PriceMatchQueue(PriceMatch):\n    QUEUE = auto()\n    QUEUE_5 = auto()\n    QUEUE_10 = auto()\n    QUEUE_20 = auto()\n# The TickerSymbol class is a subclass of AutoName.\nclass TickerSymbol(AutoName):\n    BTCUSDT = auto()\n# The Side class is a subclass of AutoName.\nclass Side(AutoName):",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TickerSymbol",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class TickerSymbol(AutoName):\n    BTCUSDT = auto()\n# The Side class is a subclass of AutoName.\nclass Side(AutoName):\n    BUY = auto()\n    SELL = auto()\n# The PositionSide class is a subclass of AutoName.\nclass PositionSide(AutoName):\n    BOTH = auto()\n    LONG = auto()",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "Side",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class Side(AutoName):\n    BUY = auto()\n    SELL = auto()\n# The PositionSide class is a subclass of AutoName.\nclass PositionSide(AutoName):\n    BOTH = auto()\n    LONG = auto()\n    SHORT = auto()\n# The Strategy class is an enumeration that represents different strategies.\nclass Strategy(Enum):",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class PositionSide(AutoName):\n    BOTH = auto()\n    LONG = auto()\n    SHORT = auto()\n# The Strategy class is an enumeration that represents different strategies.\nclass Strategy(Enum):\n    FIXED_RANGE = auto()\n    PRICE_MATCH_QUEUE = auto()\n# The OrderType class is a subclass of AutoName.\nclass OrderType(AutoName):",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "Strategy",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class Strategy(Enum):\n    FIXED_RANGE = auto()\n    PRICE_MATCH_QUEUE = auto()\n# The OrderType class is a subclass of AutoName.\nclass OrderType(AutoName):\n    LIMIT = auto()\n    MARKET = auto()\n    STOP = auto()\n    STOP_MARKET = auto()\n    TAKE_PROFIT = auto()",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class OrderType(AutoName):\n    LIMIT = auto()\n    MARKET = auto()\n    STOP = auto()\n    STOP_MARKET = auto()\n    TAKE_PROFIT = auto()\n    TAKE_PROFIT_MARKET = auto()\n    TRAILING_STOP_MARKET = auto()\n# The TIF class is a subclass of AutoName.\nclass TIF(AutoName):",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "TIF",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class TIF(AutoName):\n    GTC = auto()\n    IOC = auto()\n    FOK = auto()\n    GTX = auto()\n    GTD = auto()",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "message_handler",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def message_handler(_, message) -> None:\n    print(message)\ndef main() -> None:\n    \"\"\"\n    The main function sets up a websocket client, cancels all orders for a specific symbol, and then\n    executes a trading strategy using a process pool executor.\n    \"\"\"\n    delay_seconds = 20\n    once = False\n    listenKey = get_listen_key()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main() -> None:\n    \"\"\"\n    The main function sets up a websocket client, cancels all orders for a specific symbol, and then\n    executes a trading strategy using a process pool executor.\n    \"\"\"\n    delay_seconds = 20\n    once = False\n    listenKey = get_listen_key()\n    ws_client = UMFuturesWebsocketClient(on_message=message_handler)\n    ws_client.user_data(",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "adapter",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "adapter = HTTPAdapter(pool_connections=200, pool_maxsize=200)\nFORMAT = \"%(message)s\"\nlogging.basicConfig(\n    level=logging.ERROR,\n    format=FORMAT,\n    datefmt=\"[%X]\",\n    handlers=[RichHandler(markup=True)],\n)\nconfig_logging(logging, logging.ERROR)\ndef message_handler(_, message) -> None:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "FORMAT",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "FORMAT = \"%(message)s\"\nlogging.basicConfig(\n    level=logging.ERROR,\n    format=FORMAT,\n    datefmt=\"[%X]\",\n    handlers=[RichHandler(markup=True)],\n)\nconfig_logging(logging, logging.ERROR)\ndef message_handler(_, message) -> None:\n    print(message)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "log_client_error",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def log_client_error(error: ClientError) -> None:\n    \"\"\"\n    The function logs the details of a client error.\n    :param error: The parameter `error` is of type `ClientError`\n    :type error: ClientError\n    \"\"\"\n    logging.error(f\"{error.status_code=}, {error.error_code=}, {error.error_message=}\")\ndef cancel_all_orders_request(symbol, recvWindow: int = 2000) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function cancels all open orders for a given symbol in a futures trading platform.",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "cancel_all_orders_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def cancel_all_orders_request(symbol, recvWindow: int = 2000) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function cancels all open orders for a given symbol in a futures trading platform.\n    :param symbol: The symbol parameter represents the trading pair symbol for which you want to cancel\n    all open orders. For example, if you want to cancel all open orders for the BTC/USDT trading pair,\n    you would pass \"BTCUSDT\" as the symbol parameter\n    :param recvWindow: The `recvWindow` parameter is an optional parameter that specifies the number of\n    milliseconds the request is valid for. It is used to ensure that the request is processed within a\n    certain time frame. If the request takes longer than the specified `recvWindow` value, it will be\n    rejected. The default value, defaults to 2000",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "new_price_match_order_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def new_price_match_order_request(\n    symbol: str,\n    side: str,\n    quantity: float,\n    positionSide: str,\n    type: str,\n    timeInForce: str,\n    priceMatch: str,\n) -> Any | dict[Any, Any]:\n    \"\"\"",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "new_order_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def new_order_request(\n    symbol: str,\n    side: str,\n    quantity: float,\n    positionSide: str,\n    price: float,\n    type: str,\n    timeInForce: str,\n) -> Any | dict[Any, Any]:\n    \"\"\"",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "new_batch_order_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def new_batch_order_request(params) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function `new_batch_order_request` sends a request to a futures client to place a new batch\n    order and returns the response.\n    :param params: The `params` parameter is a dictionary that contains the necessary information for\n    creating a new batch order request. The specific keys and values in the dictionary will depend on\n    the requirements of the `um_futures_client.new_batch_order()` function\n    :return: the response from the `um_futures_client.new_batch_order(params)` method.\n    \"\"\"\n    response = {}",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_position_risk_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def get_position_risk_request(symbol: str) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function `get_position_risk_request` retrieves the position risk for a given symbol using the\n    `um_futures_client` API, and returns the response.\n    :param symbol: The symbol parameter is a string that represents the trading pair or instrument\n    symbol for which you want to retrieve the position risk information. For example, it could be\n    \"BTCUSDT\" for the Bitcoin to USDT trading pair\n    :type symbol: str\n    :return: a response object.\n    \"\"\"",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_leverage_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def get_leverage_request(symbol: str) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function `get_leverage_request` attempts to retrieve position risk information for a given\n    symbol and returns the response, or logs any client errors encountered.\n    :param symbol: The symbol parameter is a string that represents the trading symbol of a financial\n    instrument, such as a stock or a cryptocurrency\n    :type symbol: str\n    :return: a dictionary object.\n    \"\"\"\n    response = {}",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_account_info_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def get_account_info_request() -> Any | dict[Any, Any]:\n    \"\"\"\n    The function `get_account_info_request` retrieves account information from a futures client,\n    handling any potential errors.\n    :return: the response from the `um_futures_client.account()` method.\n    \"\"\"\n    response = {}\n    try:\n        response = um_futures_client.account(recvWindow=6000)\n    except ClientError as error:",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_mark_price_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def get_mark_price_request(symbol: str) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function `get_mark_price_request` sends a request to the UM Futures API to get the mark price\n    for a given symbol and returns the response.\n    :param symbol: The `symbol` parameter is a string that represents the trading pair symbol for which\n    you want to get the mark price\n    :type symbol: str\n    :return: a response, which is a dictionary.\n    \"\"\"\n    response = {}",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_listen_key_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def get_listen_key_request() -> Any | dict[Any, Any]:\n    \"\"\"\n    The function `get_listen_key_request` sends a request to create a new listen key and returns the\n    response.\n    :return: The `get_listen_key_request` function is returning a response object.\n    \"\"\"\n    response = {}\n    try:\n        response = um_futures_client.new_listen_key()\n    except ClientError as error:",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "close_listen_key_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def close_listen_key_request(listenKey: str) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function `close_listen_key_request` closes a listen key using the `um_futures_client` and\n    returns the response.\n    :param listenKey: The listenKey parameter is a string that represents a unique identifier for a\n    user's WebSocket connection. It is typically used in API calls to close the WebSocket connection and\n    stop receiving updates\n    :type listenKey: str\n    :return: a response, which is a dictionary.\n    \"\"\"",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_open_orders_request",
        "kind": 2,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "def get_open_orders_request(symbol: str) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function `get_open_orders_request` retrieves open orders for a given symbol using the\n    `um_futures_client` and handles any potential errors.\n    :param symbol: The symbol parameter is a string that represents the trading pair or symbol for which\n    you want to retrieve the open orders. It could be something like \"BTCUSDT\" for the Bitcoin to USDT\n    trading pair\n    :type symbol: str\n    :return: the response from the `um_futures_client.get_open_orders` method.\n    \"\"\"",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "adapter",
        "kind": 5,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "adapter = HTTPAdapter(pool_connections=200, pool_maxsize=200)\num_futures_client = UMFutures(key=KEY, secret=SECRET, base_url=BASE_URL)\ndef log_client_error(error: ClientError) -> None:\n    \"\"\"\n    The function logs the details of a client error.\n    :param error: The parameter `error` is of type `ClientError`\n    :type error: ClientError\n    \"\"\"\n    logging.error(f\"{error.status_code=}, {error.error_code=}, {error.error_message=}\")\ndef cancel_all_orders_request(symbol, recvWindow: int = 2000) -> Any | dict[Any, Any]:",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "um_futures_client",
        "kind": 5,
        "importPath": "network",
        "description": "network",
        "peekOfCode": "um_futures_client = UMFutures(key=KEY, secret=SECRET, base_url=BASE_URL)\ndef log_client_error(error: ClientError) -> None:\n    \"\"\"\n    The function logs the details of a client error.\n    :param error: The parameter `error` is of type `ClientError`\n    :type error: ClientError\n    \"\"\"\n    logging.error(f\"{error.status_code=}, {error.error_code=}, {error.error_message=}\")\ndef cancel_all_orders_request(symbol, recvWindow: int = 2000) -> Any | dict[Any, Any]:\n    \"\"\"",
        "detail": "network",
        "documentation": {}
    },
    {
        "label": "get_hedge_position_amount",
        "kind": 2,
        "importPath": "repo",
        "description": "repo",
        "peekOfCode": "def get_hedge_position_amount(symbol: TickerSymbol) -> float:\n    \"\"\"\n    The function `get_hedge_position_amount` returns the position amount of a given symbol.\n    :param symbol: The parameter `symbol` is of type `TickerSymbol`\n    :type symbol: TickerSymbol\n    :return: the position amount as a float.\n    \"\"\"\n    return float(get_position_risk_request(symbol=symbol.name)[0][\"positionAmt\"])\ndef get_available_balance() -> float:\n    \"\"\"",
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "get_available_balance",
        "kind": 2,
        "importPath": "repo",
        "description": "repo",
        "peekOfCode": "def get_available_balance() -> float:\n    \"\"\"\n    The function `get_available_balance` returns the available balance from an account information\n    request.\n    :return: The available balance of the account as a float value.\n    \"\"\"\n    return float(get_account_info_request()[\"availableBalance\"])\ndef get_mark_price(symbol: TickerSymbol) -> float:\n    \"\"\"\n    The function `get_mark_price` takes a `TickerSymbol` object as input and returns the mark price of",
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "get_mark_price",
        "kind": 2,
        "importPath": "repo",
        "description": "repo",
        "peekOfCode": "def get_mark_price(symbol: TickerSymbol) -> float:\n    \"\"\"\n    The function `get_mark_price` takes a `TickerSymbol` object as input and returns the mark price of\n    the symbol.\n    :param symbol: The parameter `symbol` is of type `TickerSymbol`\n    :type symbol: TickerSymbol\n    :return: the mark price of a given ticker symbol as a float value.\n    \"\"\"\n    return float(get_mark_price_request(symbol=symbol.name)[\"markPrice\"])\ndef new_order(",
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "new_order",
        "kind": 2,
        "importPath": "repo",
        "description": "repo",
        "peekOfCode": "def new_order(\n    symbol: TickerSymbol,\n    side: Side,\n    quantity: float,\n    positionSide: PositionSide,\n    price: float = -1.0,\n    type: OrderType = OrderType.LIMIT,\n    timeInForce: TIF = TIF.GTC,\n    priceMatch: PriceMatch = PriceMatchNone.NONE,\n) -> Any | dict[Any, Any]:",
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "get_leverage",
        "kind": 2,
        "importPath": "repo",
        "description": "repo",
        "peekOfCode": "def get_leverage(symbol: TickerSymbol) -> int:\n    \"\"\"\n    The function `get_leverage` takes a `TickerSymbol` object as input, sends a request to get the\n    leverage for that symbol, and returns the leverage as an integer.\n    :param symbol: The parameter \"symbol\" is of type \"TickerSymbol\"\n    :type symbol: TickerSymbol\n    :return: an integer value representing the leverage for a given ticker symbol.\n    \"\"\"\n    position_risk = get_leverage_request(symbol=symbol.name)\n    return int(position_risk[0][\"leverage\"])",
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "cancel_all_orders",
        "kind": 2,
        "importPath": "repo",
        "description": "repo",
        "peekOfCode": "def cancel_all_orders(symbol: TickerSymbol) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function cancels all orders for a given ticker symbol.\n    :param symbol: The parameter \"symbol\" is of type \"TickerSymbol\"\n    :type symbol: TickerSymbol\n    :return: The cancel_all_orders_request function is being returned.\n    \"\"\"\n    return cancel_all_orders_request(symbol=symbol.name)\ndef get_listen_key() -> str:\n    \"\"\"",
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "get_listen_key",
        "kind": 2,
        "importPath": "repo",
        "description": "repo",
        "peekOfCode": "def get_listen_key() -> str:\n    \"\"\"\n    The function `get_listen_key` returns the listen key obtained from a request to the\n    `get_listen_key_request` function.\n    :return: the value of the \"listenKey\" key from the response of the \"get_listen_key_request()\"\n    function.\n    \"\"\"\n    return get_listen_key_request()[\"listenKey\"]\ndef close_listen_key(listenKey) -> Any | dict[Any, Any]:\n    \"\"\"",
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "close_listen_key",
        "kind": 2,
        "importPath": "repo",
        "description": "repo",
        "peekOfCode": "def close_listen_key(listenKey) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function \"close_listen_key\" takes a listenKey as input and returns the result of a\n    close_listen_key_request.\n    :param listenKey: The listenKey parameter is a unique identifier that is used to establish a\n    WebSocket connection for receiving real-time updates from a server\n    :return: the result of the `close_listen_key_request` function, which is not specified in the given\n    code.\n    \"\"\"\n    return close_listen_key_request(listenKey=listenKey)",
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "get_open_orders",
        "kind": 2,
        "importPath": "repo",
        "description": "repo",
        "peekOfCode": "def get_open_orders(symbol: TickerSymbol) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function `get_open_orders` takes a `TickerSymbol` object as input and returns the result of a\n    request for open orders for that symbol.\n    :param symbol: The parameter `symbol` is of type `TickerSymbol`\n    :type symbol: TickerSymbol\n    :return: the result of the `get_open_orders_request` function call.\n    \"\"\"\n    return get_open_orders_request(symbol=symbol.name)",
        "detail": "repo",
        "documentation": {}
    },
    {
        "label": "work",
        "kind": 2,
        "importPath": "trade",
        "description": "trade",
        "peekOfCode": "def work(order) -> Any | dict[Any, Any]:\n    \"\"\"\n    The function `work` takes an order as input and creates a new order with the same parameters, but\n    with a different price depending on whether the \"priceMatch\" key is present in the order.\n    :param order: The `order` parameter is a dictionary that contains the details of an order. It has\n    the following keys:\n    :return: a new order. If the \"priceMatch\" key is present in the order dictionary, it will create a\n    new order with the \"priceMatch\" value. Otherwise, it will create a new order with the \"price\" value.\n    \"\"\"\n    if \"priceMatch\" in order:",
        "detail": "trade",
        "documentation": {}
    },
    {
        "label": "trade",
        "kind": 2,
        "importPath": "trade",
        "description": "trade",
        "peekOfCode": "def trade(\n    strategy: Strategy,\n    symbol: TickerSymbol,\n    positionSide: PositionSide,\n    buy_orders_num: int = 100,\n    sell_orders_num: int = 100,\n    tif: TIF = TIF.GTC,\n) -> list[Any]:\n    \"\"\"\n    The `trade` function executes trading orders based on the specified strategy, symbol, position side,",
        "detail": "trade",
        "documentation": {}
    },
    {
        "label": "trade_fixed_range",
        "kind": 2,
        "importPath": "trade",
        "description": "trade",
        "peekOfCode": "def trade_fixed_range(\n    symbol: TickerSymbol,\n    positionSide: PositionSide,\n    mark_price: float,\n    available_balance: float,\n    sell_amount: float,\n    leverage: int,\n    buy_orders_num: int = 100,\n    sell_orders_num: int = 100,\n    tif: TIF = TIF.GTC,",
        "detail": "trade",
        "documentation": {}
    },
    {
        "label": "trade_all_price_match_queue",
        "kind": 2,
        "importPath": "trade",
        "description": "trade",
        "peekOfCode": "def trade_all_price_match_queue(\n    symbol: TickerSymbol,\n    positionSide: PositionSide,\n    sell_amount: float,\n    buy_orders_num: int = 4,\n    sell_orders_num: int = 4,\n    tif: TIF = TIF.GTC,\n) -> list[dict[str, Any]]:\n    \"\"\"\n    The function `trade_all_price_match_queue` creates a list of buy and sell orders with specified",
        "detail": "trade",
        "documentation": {}
    },
    {
        "label": "get_max_buy_amount",
        "kind": 2,
        "importPath": "trade",
        "description": "trade",
        "peekOfCode": "def get_max_buy_amount(symbol: TickerSymbol):\n    \"\"\"\n    The function calculates the maximum amount that can be bought for a given symbol based on leverage,\n    available balance, and mark price.\n    :param symbol: The parameter \"symbol\" is of type TickerSymbol, which represents the symbol of a\n    financial instrument such as a stock or cryptocurrency\n    :type symbol: TickerSymbol\n    :return: the maximum buy amount for a given symbol.\n    \"\"\"\n    return (get_leverage(symbol=symbol) * get_available_balance()) / get_mark_price(",
        "detail": "trade",
        "documentation": {}
    },
    {
        "label": "create_order",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def create_order(\n    symbol: TickerSymbol,\n    side: Side,\n    quantity: float,\n    positionSide: PositionSide,\n    price: float = 0.0,\n    type: OrderType = OrderType.LIMIT,\n    timeInForce: TIF = TIF.GTC,\n    priceMatch: PriceMatch = PriceMatchNone.NONE,\n):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "create_all_queue_price_match_orders",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def create_all_queue_price_match_orders(\n    symbol: TickerSymbol, side: Side, positionSide: PositionSide, quantity: float\n):\n    orders = []\n    for name, member in PriceMatchQueue.__members__.items():\n        if quantity > 0.0:\n            orders.append(\n                create_order(\n                    symbol=symbol,\n                    side=side,",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "create_multiple_orders",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def create_multiple_orders(\n    symbol: TickerSymbol,\n    side: Side,\n    quantities_and_prices: list[tuple[float, float]],\n    positionSide: PositionSide,\n    type: OrderType = OrderType.LIMIT,\n    timeInForce: TIF = TIF.GTC,\n    priceMatch: PriceMatch = PriceMatchNone.NONE,\n):\n    result = []",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_orders_quantities_and_prices",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def get_orders_quantities_and_prices(\n    orders_num: int,\n    high_price: float,\n    low_price: float,\n    amount: float,\n):\n    quantities_and_prices = []\n    if amount > 0.0 and orders_num > 0:\n        quantity = amount / orders_num\n        opt_a = np.geomspace(start=low_price, stop=high_price, num=orders_num)",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "print_date_and_time",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def print_date_and_time():\n    print(f\"date and time = {datetime.datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\")\ndef get_scaled(volume_scale: float, num: int) -> tuple[list[float], float]:\n    scaled: list[float] = [1]\n    for i in range(0, num - 1):\n        scaled.append(scaled[-1] * volume_scale)\n    print(f\"{scaled=}\")\n    sum_scaled: float = float(sum(scaled))\n    return scaled, sum_scaled\ndef get_scaled_mults(scaled: list[float], sum_scaled: float) -> list[float]:",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_scaled",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def get_scaled(volume_scale: float, num: int) -> tuple[list[float], float]:\n    scaled: list[float] = [1]\n    for i in range(0, num - 1):\n        scaled.append(scaled[-1] * volume_scale)\n    print(f\"{scaled=}\")\n    sum_scaled: float = float(sum(scaled))\n    return scaled, sum_scaled\ndef get_scaled_mults(scaled: list[float], sum_scaled: float) -> list[float]:\n    return list(map(lambda x: x / sum_scaled, scaled))\ndef make_it_smaller(",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_scaled_mults",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def get_scaled_mults(scaled: list[float], sum_scaled: float) -> list[float]:\n    return list(map(lambda x: x / sum_scaled, scaled))\ndef make_it_smaller(\n    total_amount: float, final_scaled: list[float]\n) -> Any | list[float]:\n    sum_final_scaled = sum(final_scaled)\n    final_scaled[-1] = final_scaled[-1] - (sum_final_scaled - total_amount)\n    if sum_final_scaled > total_amount:\n        final_scaled = make_it_smaller(\n            total_amount=total_amount, final_scaled=final_scaled",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "make_it_smaller",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def make_it_smaller(\n    total_amount: float, final_scaled: list[float]\n) -> Any | list[float]:\n    sum_final_scaled = sum(final_scaled)\n    final_scaled[-1] = final_scaled[-1] - (sum_final_scaled - total_amount)\n    if sum_final_scaled > total_amount:\n        final_scaled = make_it_smaller(\n            total_amount=total_amount, final_scaled=final_scaled\n        )\n    return final_scaled",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_final_scaled",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def get_final_scaled(scaled_mults: list[float], total_amount: float) -> list[float]:\n    return make_it_smaller(\n        total_amount=total_amount,\n        final_scaled=list(map(lambda x: x * total_amount, scaled_mults)),\n    )\ndef get_scaled_amounts(\n    total_amount: float, volume_scale: float, num: int\n) -> list[float]:\n    scaled, sum_scaled = get_scaled(volume_scale=volume_scale, num=num)\n    scaled_mults = get_scaled_mults(scaled=scaled, sum_scaled=sum_scaled)",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_scaled_amounts",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def get_scaled_amounts(\n    total_amount: float, volume_scale: float, num: int\n) -> list[float]:\n    scaled, sum_scaled = get_scaled(volume_scale=volume_scale, num=num)\n    scaled_mults = get_scaled_mults(scaled=scaled, sum_scaled=sum_scaled)\n    return get_final_scaled(scaled_mults=scaled_mults, total_amount=total_amount)",
        "detail": "utils",
        "documentation": {}
    }
]