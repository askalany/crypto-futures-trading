# generated by datamodel-codegen:
#   filename:  binance_um_schema.json
#   timestamp: 2023-10-19T01:31:40+00:00

from __future__ import annotations

from typing import List
from typing import Optional

from data.enums import PositionSide
from pydantic import BaseModel


class Asset(BaseModel):
    asset: str
    walletBalance: float
    unrealizedProfit: float
    marginBalance: float
    maintMargin: float
    initialMargin: float
    positionInitialMargin: float
    openOrderInitialMargin: float
    crossWalletBalance: float
    crossUnPnl: float
    availableBalance: float
    maxWithdrawAmount: float
    marginAvailable: bool
    updateTime: int


class Position(BaseModel):
    symbol: str
    initialMargin: float
    maintMargin: float
    unrealizedProfit: float
    positionInitialMargin: float
    openOrderInitialMargin: float
    leverage: int
    isolated: bool
    entryPrice: float
    breakEvenPrice: float
    maxNotional: float
    bidNotional: float
    askNotional: float
    positionSide: PositionSide
    positionAmt: float
    updateTime: int


class AccountInformation(BaseModel):
    feeTier: int
    canTrade: bool
    canDeposit: bool
    canWithdraw: bool
    updateTime: int
    multiAssetsMargin: bool
    tradeGroupId: int
    totalInitialMargin: float
    totalMaintMargin: float
    totalWalletBalance: float
    totalUnrealizedProfit: float
    totalMarginBalance: float
    totalPositionInitialMargin: float
    totalOpenOrderInitialMargin: float
    totalCrossWalletBalance: float
    totalCrossUnPnl: float
    availableBalance: float
    maxWithdrawAmount: float
    assets: List[Asset]
    positions: List[Position]


class AccountBalance(BaseModel):
    accountAlias: str
    asset: str
    balance: str
    crossWalletBalance: str
    crossUnPnl: str
    availableBalance: str
    maxWithdrawAmount: str
    marginAvailable: bool
    updateTime: int


class PositionInformation(BaseModel):
    symbol: str
    positionAmt: str
    entryPrice: str
    breakEvenPrice: str
    markPrice: str
    unRealizedProfit: str
    liquidationPrice: str
    leverage: str
    maxNotionalValue: str
    marginType: str
    isolatedMargin: str
    isAutoAddMargin: str
    positionSide: str
    notional: str
    isolatedWallet: str
    updateTime: int


class BItem(BaseModel):
    a: str
    wb: str
    cw: str
    bc: str


class PItem(BaseModel):
    s: str
    pa: str
    ep: str
    bep: str
    cr: str
    up: str
    mt: str
    iw: str
    ps: str


class A(BaseModel):
    m: str
    B: List[BItem]
    P: List[PItem]


class BalanceAndPositionUpdate(BaseModel):
    e: str
    E: int
    T: int
    a: A


class PartialBookDepth(BaseModel):
    e: str
    E: int
    T: int
    U: int
    u: int
    pu: int
    b: List[List[str]]
    a: List[List[str]]


class Order(BaseModel):
    activatePrice: str
    avgPrice: str
    clientOrderId: str
    closePosition: bool
    cumQuote: str
    executedQty: str
    goodTillDate: int
    orderId: int
    origQty: str
    origType: str
    positionSide: str
    price: str
    priceMatch: str
    priceProtect: bool
    priceRate: str
    reduceOnly: bool
    selfTradePreventionMode: str
    side: str
    status: str
    stopPrice: str
    symbol: str
    time: int
    timeInForce: str
    type: str
    updateTime: int
    workingType: str


class ChangeInitialLeverage(BaseModel):
    leverage: int
    maxNotionalValue: str
    symbol: str


class UserCommissionRate(BaseModel):
    symbol: str
    makerCommissionRate: str
    takerCommissionRate: str


class CancelAllOpenOrders(BaseModel):
    code: int
    msg: str


class Bracket(BaseModel):
    bracket: int
    initialLeverage: int
    notionalCap: int
    notionalFloor: int
    maintMarginRatio: float
    cum: int


class NotionalAndLeverageBracket(BaseModel):
    symbol: str
    notionalCoef: float
    brackets: List[Bracket]


class RateLimit(BaseModel):
    interval: str
    intervalNum: int
    limit: int
    rateLimitType: str


class Asset1(BaseModel):
    asset: str
    marginAvailable: bool
    autoAssetExchange: Optional[int]


class Filter(BaseModel):
    filterType: str
    maxPrice: Optional[str] = None
    minPrice: Optional[str] = None
    tickSize: Optional[str] = None
    maxQty: Optional[str] = None
    minQty: Optional[str] = None
    stepSize: Optional[str] = None
    limit: Optional[int] = None
    notional: Optional[str] = None
    multiplierUp: Optional[str] = None
    multiplierDown: Optional[str] = None
    multiplierDecimal: Optional[int] = None


class Symbol(BaseModel):
    symbol: str
    pair: str
    contractType: str
    deliveryDate: int
    onboardDate: int
    status: str
    maintMarginPercent: str
    requiredMarginPercent: str
    baseAsset: str
    quoteAsset: str
    marginAsset: str
    pricePrecision: int
    quantityPrecision: int
    baseAssetPrecision: int
    quotePrecision: int
    underlyingType: str
    underlyingSubType: List[str]
    settlePlan: int
    triggerProtect: str
    filters: List[Filter]
    OrderType: List[str]
    timeInForce: List[str]
    liquidationFee: str
    marketTakeBound: str


class ExchangeInformation(BaseModel):
    exchangeFilters: List
    rateLimits: List[RateLimit]
    serverTime: int
    assets: List[Asset1]
    symbols: List[Symbol]
    timezone: str


class OrderBook(BaseModel):
    lastUpdateId: int
    E: int
    T: int
    bids: List[List[str]]
    asks: List[List[str]]


class SymbolPriceTickerListItem(BaseModel):
    symbol: str
    price: str
    time: int


class Model(BaseModel):
    AccountInformation: AccountInformation
    AccountBalances: List[AccountBalance]
    PositionInformation: List[PositionInformation]
    BalanceAndPositionUpdate: BalanceAndPositionUpdate
    PartialBookDepth: PartialBookDepth
    CurrentAllOpenOrders: List[Order]
    NewOrder: Order
    PlaceMultipleOrders: List[Order]
    ChangeInitialLeverage: ChangeInitialLeverage
    UserCommissionRate: UserCommissionRate
    CancelAllOpenOrders: CancelAllOpenOrders
    QueryCurrentOpenOrder: Order
    AllOrders: List[Order]
    NotionalAndLeverageBrackets: List[NotionalAndLeverageBracket]
    SymbolNotionalAndLeverageBrackets: NotionalAndLeverageBracket
    ExchangeInformation: ExchangeInformation
    OrderBook: OrderBook
    SymbolPriceTickerList: List[SymbolPriceTickerListItem]
    SymbolPriceTickerItem: SymbolPriceTickerListItem
